package it.polimi.se.eliafinazzigrazioli.adrenaline.model.cards;

import it.polimi.se.eliafinazzigrazioli.adrenaline.model.*;

import java.lang.management.PlatformLoggingMXBean;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class WeaponEffect {

    private String effectName;
    private String effectDescription;
    private List<Ammo> price;
    private ArrayList<EffectState> effectStates;
    private boolean alreadyUsed;
    private List<WeaponEffect> nextCallableEffects;
    private EffectState currentState;
    private Iterator<EffectState> stateIterator;

    private List<Player> selectedPlayers;
    private List<BoardSquare> selectedBoardSquares;
    private List<Room> selectedRooms;
    private List<Player> toAffect;
    private BoardSquare movementDestination;
    private List<Player> shotPlayers;
    private List<Player> movedPlayers;

    private List<Player> toSelectPlayers;
    private List<BoardSquare> toSelectBoardSquares;
    private List<Room> toSelectRooms;

    public WeaponEffect(EffectState currentState, List<Player> players){
        this.currentState = currentState;
        this.toSelectPlayers = players;
    }


    public Player getSelectedPlayer(int selectionOrder){
        return selectedPlayers.get(selectionOrder);
    }

    public BoardSquare getSelectedBoardSquare(int selectionOrder){
        return selectedBoardSquares.get(selectionOrder);
    }

    public Room getSelectedRoom(int selectionOrder){
        return selectedRooms.get(selectionOrder);
    }

    public BoardSquare getMovementDestination() {
        return movementDestination;
    }

    public List<Player> getToAffect() {
        return new ArrayList<Player>(toAffect);
    }

    public void addShotPlayers(List<Player> toAdd){
        shotPlayers.addAll(toAdd);
    }

    public void addMovedPlayers(List<Player> toAdd){
        movedPlayers.addAll(toAdd);
    }

    public void execute(WeaponCard invoker, GameBoard gameBoard, Player currentPlayer) {
        while (!currentState.selectionIsRequired() && !currentState.isFinal()){
            currentState.execute(invoker, gameBoard, currentPlayer); //A selection event is to be generated by the effect state
        }
        if (currentState.isFinal()){
            //TODO generate a termination event containing next callable effects
        }
    }

    public boolean isAlreadyUsed(){
        return alreadyUsed;
    }

    public void updateToSelectPlayers(List<Player> newSelectedPlayers){ //List of players built by last visibility step to be intersected with the previously computed
        List<Player> newToSelectPlayers = new ArrayList<>();
        for (Player player:toSelectPlayers){
            if (newSelectedPlayers.contains(player))
                newToSelectPlayers.add(player);
        }
        toSelectPlayers = newToSelectPlayers;
    }

    public void updateToSelectBoardSquares(List<BoardSquare> newSelectedBoardSquares){
        List<BoardSquare> newToSelectBoardSquares = new ArrayList<>();
        for (BoardSquare boardSquare:toSelectBoardSquares){
            if (newSelectedBoardSquares.contains(boardSquare))
                newToSelectBoardSquares.add(boardSquare);
        }
        toSelectBoardSquares = newToSelectBoardSquares;
    }

    public void updateToSelectRooms(List<Room> newSelectedRooms){
        List<Room> newToSelectRooms = new ArrayList<>();
        for (Room roomColor:toSelectRooms){
            if (newSelectedRooms.contains(roomColor))
                newToSelectRooms.add(roomColor);
        }
        toSelectRooms = newToSelectRooms;
    }

    public List<WeaponEffect> getNextCallableEffects() {
        List<WeaponEffect> notUsedYetEffects = new ArrayList<>();

        for (WeaponEffect callableEffect: nextCallableEffects) {
            if (!callableEffect.isAlreadyUsed())
                notUsedYetEffects.add(callableEffect);
        }

        return notUsedYetEffects;
    }

}
