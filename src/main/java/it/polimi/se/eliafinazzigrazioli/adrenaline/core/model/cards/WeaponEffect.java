package it.polimi.se.eliafinazzigrazioli.adrenaline.core.model.cards;

import it.polimi.se.eliafinazzigrazioli.adrenaline.core.model.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

public class WeaponEffect {

    private String effectName;
    private String effectDescription;
    private List<Ammo> price;
    private ArrayList<EffectState> effectStates;
    private boolean alreadyUsed;
    private List<WeaponEffect> nextCallableEffects;
    private EffectState currentState;
    private Iterator<EffectState> stateIterator;

    private List<Player> selectedPlayers;
    private List<BoardSquare> selectedBoardSquares;
    private List<Room> selectedRooms;
    private List<Player> toAffect;
    private BoardSquare movementDestination;
    private List<Player> shotPlayers;
    private List<Player> movedPlayers;

    /*
     This flag is used to in the update lists methods to avoid filtering
     and simply add selected items when no visibility class has been run.
     */
    private boolean beginningSelectionBuilding;
    private List<Player> toSelectPlayers;
    private List<BoardSquare> toSelectBoardSquares;
    private List<Room> toSelectRooms;

    public WeaponEffect(EffectState currentState, List<Player> players){
        this.currentState = currentState;
        this.toSelectPlayers = players;

        selectedRooms = new ArrayList<>(Arrays.asList(Room.PURPLE));

        beginningSelectionBuilding = true;
        toSelectPlayers = new ArrayList<>();
        toSelectBoardSquares = new ArrayList<>();
        toSelectRooms = new ArrayList<>();

    }


    public Player getSelectedPlayer(int selectionOrder){
        return selectedPlayers.get(selectionOrder);
    }

    public BoardSquare getSelectedBoardSquare(int selectionOrder){
        return selectedBoardSquares.get(selectionOrder);
    }

    public Room getSelectedRoom(int selectionOrder){
        return selectedRooms.get(selectionOrder);
    }

    public List<Player> getToSelectPlayers() {
        return new ArrayList<>(toSelectPlayers);
    }

    public List<BoardSquare> getToSelectBoardSquares() {
        return new ArrayList<>(toSelectBoardSquares);
    }

    public List<Room> getToSelectRooms() {
        return new ArrayList<>(toSelectRooms);
    }

    public BoardSquare getMovementDestination() {
        return movementDestination;
    }

    public List<Player> getToAffect() {
        return new ArrayList<Player>(toAffect);
    }

    public void setCurrentState(EffectState currentState) {
        this.currentState = currentState;
    }

    public void addShotPlayers(List<Player> toAdd){
        shotPlayers.addAll(toAdd);
    }

    public void addMovedPlayers(List<Player> toAdd){
        movedPlayers.addAll(toAdd);
    }

    public void execute(WeaponCard invoker, GameBoard gameBoard, Player currentPlayer) {
        while (!currentState.selectionIsRequired() && !currentState.isFinal()){
            currentState.execute(invoker, gameBoard, currentPlayer); //A selection event is to be generated by the effect state
        }
        if (currentState.isFinal()){
            //TODO generate a termination event containing next callable effects
        }
    }

    public boolean isAlreadyUsed(){
        return alreadyUsed;
    }

    public void updateToSelectPlayers(List<Player> newSelectedPlayers){ //List of players built by last visibility step to be intersected with the previously computed
        if (beginningSelectionBuilding) {
            toSelectPlayers = newSelectedPlayers;
            beginningSelectionBuilding = false;
        }
        else {
            List<Player> newToSelectPlayers = new ArrayList<>();
            for (Player player : toSelectPlayers) {
                if (newSelectedPlayers.contains(player))
                    newToSelectPlayers.add(player);
            }
            toSelectPlayers = newToSelectPlayers;
        }
    }

    public void updateToSelectBoardSquares(List<BoardSquare> newSelectedBoardSquares){
        if (beginningSelectionBuilding) {
            toSelectBoardSquares = newSelectedBoardSquares;
            beginningSelectionBuilding = false;
        }
        else {
            List<BoardSquare> newToSelectBoardSquares = new ArrayList<>();
            for (BoardSquare boardSquare : toSelectBoardSquares) {
                if (newSelectedBoardSquares.contains(boardSquare))
                    newToSelectBoardSquares.add(boardSquare);
            }
            toSelectBoardSquares = newToSelectBoardSquares;
        }
    }

    public void updateToSelectRooms(List<Room> newSelectedRooms){
        if (beginningSelectionBuilding) {
            toSelectRooms = newSelectedRooms;
            beginningSelectionBuilding = false;
        }
        else {
            List<Room> newToSelectRooms = new ArrayList<>();
            for (Room roomColor : toSelectRooms) {
                if (newSelectedRooms.contains(roomColor))
                    newToSelectRooms.add(roomColor);
            }
            toSelectRooms = newToSelectRooms;
        }
    }

    public List<WeaponEffect> getNextCallableEffects() {
        List<WeaponEffect> notUsedYetEffects = new ArrayList<>();

        for (WeaponEffect callableEffect: nextCallableEffects) {
            if (!callableEffect.isAlreadyUsed())
                notUsedYetEffects.add(callableEffect);
        }

        return notUsedYetEffects;
    }

}
